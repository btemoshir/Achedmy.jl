var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page documents all public functions and types in Achedmy.jl.","category":"section"},{"location":"api/#Main-Types","page":"API Reference","title":"Main Types","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#Symmetry-Types","page":"API Reference","title":"Symmetry Types","text":"Beyond Response, Achedmy defines additional symmetry types for Green's functions:\n\nCorrelation: Enforces block symmetry for cross-species correlations\nOnePoint: For mean-field (one-point) functions\n\nSee the source code in src/Var.jl for implementation details.","category":"section"},{"location":"api/#Internal-Functions","page":"API Reference","title":"Internal Functions","text":"The following internal functions have detailed docstrings in the source code but are not part of the public API:","category":"section"},{"location":"api/#Self-Energy-Functions-([src/SelfEnergy.jl](https://github.com/btemoshir/Achedmy.jl/blob/main/src/SelfEnergy.jl))","page":"API Reference","title":"Self-Energy Functions (src/SelfEnergy.jl)","text":"self_energy_mak_noC! - MAK approximation without correlations\nself_energy_alpha2! - Œ±¬≤ expansion self-energy\nself_energy_SBR! - Single-species SBR approximation\nself_energy_SBR_mixed! - Mixed SBR for multiple species\nself_energy_SBR_mixed_cross_noC! - Cross-species SBR without initial correlations\nself_energy_alpha2_cross! - Cross-species Œ±¬≤ expansion","category":"section"},{"location":"api/#Coefficient-Functions-([src/Cmn.jl](https://github.com/btemoshir/Achedmy.jl/blob/main/src/Cmn.jl))","page":"API Reference","title":"Coefficient Functions (src/Cmn.jl)","text":"mnList - Generate (m,n) index pairs\nc_mn_no_mu - Coefficient calculation without mean-field\nc_mn - Full coefficient with mean-field\nc_mnFULL - Complete coefficient matrix\nc_mnFULL_test - Test version with validation\ncreate_c_mn_dict - Dictionary of coefficients","category":"section"},{"location":"api/#Block-Operations-([src/BlockOp.jl](https://github.com/btemoshir/Achedmy.jl/blob/main/src/BlockOp.jl))","page":"API Reference","title":"Block Operations (src/BlockOp.jl)","text":"block_tri_lower_inverse - Inverse of block lower-triangular matrix\nblock_mat_mul - Block matrix multiplication\nblock_mat_mix_mul - Mixed block multiplication\nblock_lower_shift - Shift operation for block matrices\nblock_identity - Block identity matrix\nblock_vec_mat_mul_single_sp - Vector-matrix product for single species\nresponse_combinations - Generate response function index combinations\n\nFor detailed mathematical descriptions and usage examples, see the comprehensive docstrings in each source file.\n\nSee the source code for detailed docstrings of internal functions.","category":"section"},{"location":"api/#Achedmy.Achedmy","page":"API Reference","title":"Achedmy.Achedmy","text":"Achedmy\n\nAdaptive CHEmical Dynamics using MemorY\n\nA Julia package for computing memory-corrected dynamics of chemical reaction networks (CRNs)  with discrete molecular number fluctuations using dynamical free energy and Plefka expansions.\n\nApproximation Methods\n\ngSBR: Generalized self-consistent bubble resummation (recommended)\nSBR: Self-consistent bubble resummation (ignores the joint fluctuations induced by different reactions)\nMCA: Mode coupling approximation (O(Œ±^2))\nMAK: Mass action kinetics (mean-field)\n\nMain Types\n\nReactionStructure: Stores reaction network stoichiometry and rates\nReactionVariables: Stores dynamical variables (means, correlations, responses, self-energies)\n\nMain Functions\n\nsolve_dynamics!: Integrate the memory-corrected equations\nReactionStructure: Constructor from Catalyst networks\nReactionVariables: Initialize variables container\n\nQuick Example\n\nusing Achedmy, Catalyst\n\n# Define reaction network\nrn = @reaction_network begin\n    @species S(t)=1.0 P(t)=0.1\n    @parameters k=1.0 d=0.1\n    k, S --> S + P\n    d, P --> 0\nend\n\n# Setup and solve\nstructure = ReactionStructure(rn)\nvariables = ReactionVariables(structure, \"cross\")\nsol = solve_dynamics!(structure, variables, \n                     selfEnergy=\"gSBR\", tmax=10.0)\n\n# Extract results\nmean_P = variables.Œº[2, :]  # Mean protein count\nvariance_P = diag(variables.N[2,2,:,:])  # Variance over time\n\nCitation\n\nIf you use Achedmy.jl in your research, please cite:\n\nHarsh, M. (2025). Memory-corrected dynamics of chemical reaction networks  via Plefka expansion. In preparation.\n\nSee Also\n\nGitHub Repository\nCatalyst.jl\nKadanoffBaym.jl\n\n\n\n\n\n","category":"module"},{"location":"api/#Achedmy.ReactionStructure","page":"API Reference","title":"Achedmy.ReactionStructure","text":"ReactionStructure\n\nStores the stoichiometry and rate information for a chemical reaction network.\n\nFields\n\nnum_species::Int: Number of chemical species in the network\nnum_interactions::Int: Number of interaction reactions (non-baseline reactions or reactions other than simple creation/destruction)\nnum_reactions::Int: Total number of reactions (creation + destruction + interactions)\nrate_creation::Vector{Float64}: Rate constants for spontaneous creation reactions\nrate_destruction::Vector{Float64}: Rate constants for destruction reactions\nrate_interaction::Vector{Float64}: Rate constants for interaction reactions\nstochiometry_prod::Matrix{Int}: Stoichiometry matrix for products for each interaction reaction\nstochiometry_react::Matrix{Int}: Stoichiometry matrix for reactants for each interaction reaction\ninitial_values::Vector{Float64}: Initial molecular counts for each species\nn_list: List of reaction vectors for generating combinatorial structures\nn_list_union: Union of all reaction vectors\nm_list: List of auxiliary reaction vectors\nm_list_union: Union of auxiliary reaction vectors\ninitial_C::Union{Vector{Float64}, Matrix{Float64}}: Initial correlations C(0,0) - can be a vector for single-species or matrix for inter-species correlations\n\nConstructor\n\nReactionStructure(reaction_system::ReactionSystem; \n                 external_initialization=false,\n                 initial_correlations=false)\n\nCreate a ReactionStructure from a Catalyst ReactionSystem.\n\nArguments\n\nreaction_system::ReactionSystem: Catalyst reaction network\nexternal_initialization::Union{Dict,Bool}=false: External rates/values not in Catalyst define reaction_system\ninitial_correlations::Union{Vector,Matrix,Bool}=false: Initial correlation values C(0,0)\nVector: For single-species correlations (size: num_species)\nMatrix: For cross-species correlations (size: numspecies √ó numspecies)\nfalse: Zero initial correlations (default)\n\nReactions are categorized as:\n\nCreation: ‚àÖ ‚Üí A (rate: k‚ÇÅ)\nDestruction: A ‚Üí ‚àÖ (rate: k‚ÇÇ)\nInteractions: A + B ‚Üí C (rate: k‚ÇÉ)\n\nExample\n\nusing Catalyst, Achedmy\n\n# Define gene regulation network\ngene_network = @reaction_network begin\n    @species G(t)=0.01 P(t)=10.0\n    @parameters k_on=0.1 k_off=1.0 k_p=10.0 k_d=1.0\n    (k_on, k_off), 0 <--> G\n    k_p, G --> G + P\n    k_d, P --> 0\nend\n\n# Create structure\nstructure = ReactionStructure(gene_network)\nprintln(\"Number of species: \", structure.num_species)\nprintln(\"Initial protein count: \", structure.initial_values[2])\nprintln(\"Creation rates: \", structure.rate_creation)\n\nNotes\n\nNon-zero initial correlations are currently not supported but planned for future versions\nSpecies order is determined by the order in the ReactionSystem\nExternal initialization is useful for parameter sweeps\n\nSee Also\n\nReactionVariables: Storage for dynamical variables\nsolve_dynamics!: Solve the dynamics\n\n\n\n\n\n","category":"type"},{"location":"api/#Achedmy.ReactionVariables","page":"API Reference","title":"Achedmy.ReactionVariables","text":"ReactionVariables\n\nStorage container for all dynamical variables computed during the simulation.\n\nFields\n\nresponse_type::String: Either \"single\" (diagonal only) or \"cross\" (full matrix)\nŒº::GreenFunction: Mean molecular numbers, langle n_i(t) rangle\nSize: (num_species, num_timesteps)\nR::GreenFunction: Response function, R_ij(tt)\nSingle: Size (num_species, num_timesteps, num_timesteps)\nCross: Size (num_species, num_species, num_timesteps, num_timesteps)\nMeasures response to perturbations\nCausal: R_ij(tt) = 0 for t  t\nC::GreenFunction: Connected correlation function, C_ij(tt)\nSame dimensions as R\nC_ij(tt) = langle delta phi_i(t) delta phi_j(t) rangle_c\nN::GreenFunction: Number-number correlator, N_ij(tt)\nSame dimensions as R\nN_ij(tt) = langle delta n_i(t) delta n_j(t) rangle\nRelated to C by: N = C + R otimes mu\nŒ£_R::GreenFunction: Response self-energy (memory kernel)\nŒ£_Œº::GreenFunction: Mean self-energy (memory kernel)\nŒ£_B::GreenFunction: Correlation self-energy (memory kernel)\n\nResponse Types\n\n\"single\" Mode\n\nTracks only diagonal elements (single-species correlations)\nMemory usage: O(N √ó T^n) where N = numspecies, T = numtimesteps, n = depends on the approximation used\nFaster for large systems with weak cross-correlations\n\n\"cross\" Mode\n\nTracks full matrix (all cross-species correlations)\nMemory usage: O(N¬≤ √ó T^n) where N = numspecies, T = numtimesteps, n = depends on the approximation used\nMore accurate, captures all correlations\n\nConstructor\n\nReactionVariables(structure::ReactionStructure, response_type::String=\"cross\")\n\nInitialize storage arrays for dynamics computation.\n\nArguments\n\nstructure::ReactionStructure: Reaction network structure\nresponse_type::String: Either \"cross\" (default) or \"single\"\n\nExample\n\nusing Achedmy, Catalyst\n\nenzyme = @reaction_network begin\n    @species S(t)=1.0 E(t)=0.9 C(t)=0.1 P(t)=0.0\n    @parameters k_f=1.0 k_b=0.1 k_cat=1.0\n    (k_f, k_b), S + E <--> C\n    k_cat, C --> E + P\nend\n\nstructure = ReactionStructure(enzyme)\n\n# Full cross-correlations (recommended)\nvars_cross = ReactionVariables(structure, \"cross\")\nsol_cross = solve_dynamics!(structure, vars_cross, selfEnergy=\"gSBR\", tmax=5.0)\n\n# Single-species only (memory efficient)\nvars_single = ReactionVariables(structure, \"single\")\nsol_single = solve_dynamics!(structure, vars_single, selfEnergy=\"gSBR\", tmax=5.0)\n\n# Access results\nmean_substrate = vars_cross.Œº[1, :]              # Mean S(t)\nvariance_product = diag(vars_cross.N[4,4,:,:])  # Var(P) over time\nresponse_SE = vars_cross.R[1,2,:,:]              # R_SE(t,t')\ncross_corr_SP = vars_cross.N[1,4,:,:]            # ‚ü®Œ¥S(t)Œ¥P(t')‚ü©\n\nPerformance Tips\n\nUse \"single\" for systems with >10 species to save memory\nFor weakly coupled systems, \"single\" may be sufficient\n\nSee Also\n\nReactionStructure\nsolve_dynamics!\nResponse: Symmetry types\n\n\n\n\n\n","category":"type"},{"location":"api/#Achedmy.Response","page":"API Reference","title":"Achedmy.Response","text":"Response\n\nDefined as  G(tt) = 0 if t  t\n\n\n\n\n\n","category":"type"},{"location":"api/#Achedmy.solve_dynamics!","page":"API Reference","title":"Achedmy.solve_dynamics!","text":"solve_dynamics!(structure, variables; kwargs...)\n\nSolve the memory-corrected dynamics for a chemical reaction network.\n\nArguments\n\nstructure::ReactionStructure: Reaction network structure with stoichiometry and rates\nvariables::ReactionVariables: Storage container for dynamical variables (modified in-place)\n\nApproximation Method\n\nselfEnergy::String = \"gSBR\": Self-energy approximation scheme\n\"gSBR\": Generalized self-consistent bubble resummation Recommended\n\"SBR\": Self-consistent bubble resummation (single-species only, ignores the joint fluctuations induced by different reactions)\n\"MCA\": Mode coupling approximation (perturbative to O(Œ±¬≤))\n\"MAK\": Mass action kinetics (mean-field, no memory)\n\nTime Parameters\n\ntstart::Float64 = 0.0: Initial time\ntmax::Float64 = 1.0: Final simulation time\n\nSolver Tolerances\n\natol::Float64 = 1e-3: Absolute tolerance for adaptive solver\nrtol::Float64 = 1e-2: Relative tolerance for adaptive solver\n\nAdvanced Solver Parameters\n\nk_max::Int = 12: Maximum interpolation order\ndtini::Float64 = 0.0: Initial time step (0 = auto)\ndtmax::Float64 = Inf: Maximum time step\nqmax::Float64 = 5: Maximum step size growth factor\nqmin::Float64 = 1//5: Minimum step size shrink factor\nŒ≥::Float64 = 9//10: Safety factor for step size adaptation\nkmax_vie::Int = k_max √∑ 2: Maximum order for Volterra integral equations\n\nReturns\n\nsol: Solution object from kbsolve! with fields:\nt::Vector{Float64}: Adaptive time grid\nw::Vector{Vector{Float64}}: Integration weights at each time step\nretcode::Symbol: Solution status (:Success if converged)\n\nSide Effects\n\nThe variables object is modified in-place with computed values:\n\nvariables.Œº: Mean trajectories\nvariables.R: Response functions\nvariables.C: Correlation functions\nvariables.N: Number-number correlators\nvariables.Œ£_R, variables.Œ£_Œº, variables.Œ£_B: Self-energies\n\nAlgorithm\n\nSolves coupled integro-differential Kadanoff-Baym equations:\n\nbeginaligned\npartial_t mu_i(t) = k_1i - k_2i mu_i(t) + Sigma_mu^i(t) \n(partial_t + k_2i) R_ij(tt) = delta(t-t) delta_ij + int_t^t dtau  sum_k Sigma_R^ik(ttau) R_kj(taut)\nendaligned\n\nwhere self-energies Sigma are computed according to the chosen approximation method.\n\nApproximation Methods Explained\n\ngSBR (Generalized Self-consistent Bubble Resummation) ‚≠ê\n\nAccuracy: Best available, validated against numerical solutions of the master equation\nIncludes: All cross-species and cross-reaction corrections and full memory effects\nUse when: Accuracy is critical, small molecule numbers\nWorks with: Both \"single\" and \"cross\" response types\n\nSBR (Self-consistent Bubble Resummation)\n\nAccuracy: Good for weakly coupled systems\nIncludes: Only diagonal self-energies, no cross-species nor cross-reaction memory corrections\nUse when: Species are weakly coupled\nRestriction: Only works with \"single\" response type\n\nMCA (Mode Coupling Approximation)\n\nAccuracy: Perturbative O(Œ±¬≤) correction to MAK\nIncludes: Leading-order fluctuation corrections\nUse when: Fluctuations are weak\nUnstable: May lead to numerical instabilities in most cases with large reaction rates\nWorks with: Both \"single\" and \"cross\" response types\n\nMAK (Mass Action Kinetics)\n\nAccuracy: Mean-field only, no fluctuations\nIncludes: No memory effects\nUse when: Quick baseline comparison needed\nLimitation: Fails for small molecule counts\n\nExample\n\nusing Achedmy, Catalyst\n\n# Define Michaelis-Menten enzyme kinetics\nenzyme = @reaction_network begin\n    @species S(t)=1.0 E(t)=0.9 C(t)=0.1 P(t)=0.0\n    @parameters k_f=1.0 k_b=0.1 k_cat=1.0\n    (k_f, k_b), S + E <--> C\n    k_cat, C --> E + P\nend\n\n# Setup\nstructure = ReactionStructure(enzyme)\nvariables = ReactionVariables(structure, \"cross\")\n\n# Solve with high accuracy\nsol = solve_dynamics!(\n    structure, \n    variables,\n    selfEnergy = \"gSBR\",\n    tmax = 5.0,\n    tstart = 0.0,\n    atol = 1e-4,\n    rtol = 1e-3\n)\n\n# Check convergence\n@assert sol.retcode == :Success \"Solver did not converge!\"\n\n# Extract results\ntime = sol.t\nmean_product = variables.Œº[4, :]  # P(t)\nvariance_product = diag(variables.N[4,4,:,:])  # Var[P(t)]\nresponse_SE = variables.R[1,2,:,:]  # How E responds to perturbation in S\n\n# Visualize\nusing PyPlot\nfigure(figsize=(10,4))\nsubplot(121)\nplot(time, mean_product)\nxlabel(\"Time\")\nylabel(\"‚ü®P(t)‚ü©\")\n\nsubplot(122)\nplot(time, variance_product)\nxlabel(\"Time\")\nylabel(\"Var[P(t)]\")\n\nPerformance Tips\n\nStart loose, tighten if needed: Begin with atol=1e-3, rtol=1e-2\nTime range: Longer tmax increases cost quadratically or cubically due to memory integrals\nMethod selection:\nProduction runs: gSBR with \"cross\"\nLarge systems (>10 species): gSBR with \"single\"\nQuick tests: MAK or MCA\nTolerance tuning: If variances go negative, decrease tolerances\n\nCommon Issues\n\nNegative Variances\n\nProblem: diag(variables.N[i,i,:,:]) contains negative values\n\nSolutions:\n\nDecrease atol and rtol (e.g., 1e-5)\nUse \"cross\" response type instead of \"single\"\nReduce tmax or increase dtmax to limit time range\nCheck that initial conditions are physical (non-negative)\n\nSlow Convergence\n\nProblem: Simulation takes too long\n\nSolutions:\n\nIncrease tolerances to atol=1e-2, rtol=1e-1\nSwitch from \"cross\" to \"single\" response type\nUse SBR or MCA instead of gSBR\nReduce tmax or limit time range\n\nSBR with cross response error\n\nProblem: Error when using selfEnergy=\"SBR\" with response_type=\"cross\"\n\nSolution: Use selfEnergy=\"gSBR\" or change to response_type=\"single\"\n\nSee Also\n\nReactionStructure: Define reaction networks\nReactionVariables: Storage container\nKadanoffBaym.jl: Underlying solver\nCatalyst.jl: Reaction network DSL\n\n\n\n\n\n","category":"function"},{"location":"theory/#Mathematical-Theory","page":"Theory","title":"Mathematical Theory","text":"This page explains the theoretical framework underlying Achedmy.jl, from the master equation to the various approximation schemes.","category":"section"},{"location":"theory/#The-Chemical-Master-Equation","page":"Theory","title":"The Chemical Master Equation","text":"Reaction networks with stochastic dynamics are governed by the Master Equation:\n\nfracpartial P(mathbfn t)partial t = sum_alpha k_alpha left E_-mathbfs_alpha + mathbfr_alpha - 1 right left( prod_i n_i^r_i^alpha right) P(mathbfn t)\n\nwhere:\n\nP(mathbfn t)\n= probability of state mathbfn at time t\nk_alpha\n= rate of reaction alpha\nmathbfs_alpha\n= product stoichiometry\nmathbfr_alpha\n= reactant stoichiometry\nE_mathbfm\n= step operator: E_mathbfm f(mathbfn) = f(mathbfn + mathbfm)","category":"section"},{"location":"theory/#The-Challenge","page":"Theory","title":"The Challenge","text":"Solving the Master Equation exactly requires tracking mathcalO(N^M) states (N = typical copy number, M = species). This becomes intractable for even modest systems.","category":"section"},{"location":"theory/#The-Plefka-Expansion","page":"Theory","title":"The Plefka Expansion","text":"Achedmy uses the Plefka expansion (TAP approximation) to derive closed equations for:\n\nMean densities: mu_i(t) = langle n_i(t) rangle\nResponse functions: R_ij(tt) = fracdelta mu_i(t)delta h_j(t)\nCorrelation functions: N_ij(tt) = langle Delta n_i(t) Delta n_j(t) rangle\n\nwhere Delta n_i = n_i - mu_i.","category":"section"},{"location":"theory/#Effective-Action","page":"Theory","title":"Effective Action","text":"The Plefka expansion starts from the effective action:\n\nSmu R = -log Zh - int dt sum_i h_i(t) mu_i(t) + frac12 int dt dt sum_ij h_i(t) R_ij(tt) h_j(t)\n\nExtremizing this action gives memory-corrected equations of motion.","category":"section"},{"location":"theory/#Equations-of-Motion","page":"Theory","title":"Equations of Motion","text":"","category":"section"},{"location":"theory/#Response-Function-Equation","page":"Theory","title":"Response Function Equation","text":"The response function satisfies a Kadanoff-Baym equation:\n\nleft fracpartialpartial t delta_ij - A_ij(t) right R_jk(tt) = delta_ik delta(t-t) + int_t^t dt  Sigma_R^ij(tt) R_jk(tt)\n\nwhere:\n\nA_ij(t)\n= Jacobian of mean-field dynamics\nSigma_R^ij(tt)\n= self-energy (memory kernel)","category":"section"},{"location":"theory/#Correlation-Function-Equation","page":"Theory","title":"Correlation Function Equation","text":"Similarly for correlations:\n\nN_ij(tt) = int_t_0^min(tt) dt  R_ik(tt) Sigma_B^kl(tt) R_lj(tt)\n\nwhere:\n\nSigma_B^kl(tt)\n= Born self-energy (noise kernel)","category":"section"},{"location":"theory/#Mean-Density-Equation","page":"Theory","title":"Mean Density Equation","text":"The mean evolves with a memory term:\n\nfracdmu_i(t)dt = sum_alpha k_alpha (s_i^alpha - r_i^alpha) mu^mathbfr_alpha(t) + int_t_0^t dt  Sigma_mu^i(tt)\n\nwhere:\n\nSigma_mu^i(tt)\n= mean-field correction from fluctuations","category":"section"},{"location":"theory/#The-Self-Energy:-Different-Approximations","page":"Theory","title":"The Self-Energy: Different Approximations","text":"The key challenge is computing the self-energy Sigma. Achedmy implements four approximation schemes:","category":"section"},{"location":"theory/#1.-MAK-(Mean-field-Approximation-with-Kinetics)","page":"Theory","title":"1. MAK (Mean-field Approximation with Kinetics)","text":"Assumption: Neglect all memory effects (Sigma approx 0).\n\nEquations:\n\nbeginaligned\nSigma_R^ij(tt) = 0 \nSigma_mu^i(tt) = 0 \nSigma_B^ij(tt) = sum_alpha k_alpha (s_i^alpha + r_i^alpha) mu^mathbfr_alpha(t)\nendaligned\n\nPros: \n\nFastest (no memory integrals)\nSimple analytic structure\n\nCons:\n\nInaccurate for systems with strong fluctuations\nNo memory effects\n\nWhen to use: Quick estimates, mean-field dominated systems","category":"section"},{"location":"theory/#2.-MCA-(Mode-Coupling-Approximation)","page":"Theory","title":"2. MCA (Mode Coupling Approximation)","text":"Assumption: Perturbative expansion to mathcalO(alpha^2) in the \"vertex\" parameter alpha.\n\nSelf-energy:\n\nSigma_R^ij(tt) = sum_alphabeta sum_mn c_mn^(alphabeta)(t) prod_k R_kk(tt)^m_k+n_k\n\nwhere:\n\nc_mn^(alphabeta)\n= combinatorial coefficients (see c_mnFULL in Cmn.jl)\nSum restricted to m + n  3 (second-order)\n\nPros:\n\nCaptures leading-order memory effects\nModerate computational cost\n\nCons:\n\nPerturbative (fails for large alpha)\nNo self-consistent resummation\n\nWhen to use: Weak to moderate fluctuations","category":"section"},{"location":"theory/#3.-SBR-(Single-species-Bubble-Resummation)","page":"Theory","title":"3. SBR (Single-species Bubble Resummation)","text":"Assumption: Resum geometric series of \"bubble\" diagrams for each species independently.\n\nSelf-energy:\n\nSigma_R^ii(tt) = sum_mn c_mni(t) left frac11 - chi_i right R_ii(tt)^m_i+n_i\n\nwhere:\n\nchi_i = c_mni R_ii^m_i+n_i\n(bubble series for species i)\nfrac11-chi_i\n= geometric series: 1 + chi_i + chi_i^2 + cdots\n\nPros:\n\nSelf-consistent (not perturbative)\nCaptures multi-order memory effects\nModerate cost (no matrix inversion)\n\nCons:\n\nNeglects cross-species correlations\nLess accurate than gSBR for coupled systems\n\nWhen to use: Single-species dominant, moderate coupling","category":"section"},{"location":"theory/#4.-gSBR-(Generalized-SBR)","page":"Theory","title":"4. gSBR (Generalized SBR)","text":"Assumption: Resum bubble series with full cross-species coupling.\n\nSelf-energy:\n\nSigma_R^ij(tt) = sum_mn c_mn^(alphabeta)(t) left (I + Sigma_R cdot R)^-1 right_ij R_ik(tt)^m_k R_jl(tt)^n_l\n\nwhere:\n\nI + Sigma_R cdot R\n= full operator to invert (via block_tri_lower_inverse in BlockOp.jl)\nAll cross-species terms R_ij included\n\nPros:\n\nMost accurate approximation\nCaptures cross-species correlations\nSelf-consistent resummation\n\nCons:\n\nMost expensive (mathcalO(N^4 T^3))\nRequires block matrix inversion\n\nWhen to use: Strong coupling, cross-species correlations important","category":"section"},{"location":"theory/#Comparison-of-Methods","page":"Theory","title":"Comparison of Methods","text":"Feature MAK MCA SBR gSBR\nComplexity mathcalO(N T) mathcalO(N T^2) mathcalO(N T^2) mathcalO(N^4 T^3)\nMemory effects ‚úó ‚úì (pert.) ‚úì (self-cons.) ‚úì (self-cons.)\nCross-species ‚úó ‚úó ‚úó ‚úì\nSelf-consistent N/A ‚úó ‚úì ‚úì\nAccuracy ‚≠ê ‚≠ê‚≠ê ‚≠ê‚≠ê‚≠ê ‚≠ê‚≠ê‚≠ê‚≠ê","category":"section"},{"location":"theory/#The-Coefficient-Functions","page":"Theory","title":"The Coefficient Functions","text":"A key component is the coefficient c_mn^alpha(t):\n\nc_mn^alpha(t) = k_alpha left prod_i binoms_i^alpham_i - prod_i binomr_i^alpham_i right prod_i binomr_i^alphan_i mu^mathbfr_alpha - mathbfn(t)\n\nThese encode:\n\nReaction rates (k_alpha)\nStoichiometric structure (binomial coefficients)\nMean-field densities (mu^mathbfr-mathbfn)\n\nSee c_mnFULL in Cmn.jl for implementation details.","category":"section"},{"location":"theory/#Block-Matrix-Structure-(gSBR)","page":"Theory","title":"Block Matrix Structure (gSBR)","text":"The gSBR self-energy requires inverting a block lower-triangular matrix:\n\nXi = left I - chi right^-1\n\nwhere:\n\nBlock dimension: Different (mn) pairs\nTime dimension: Lower-triangular causality structure\n\nThis is computed efficiently using forward elimination (see block_tri_lower_inverse in BlockOp.jl) rather than naive matrix inversion.","category":"section"},{"location":"theory/#Geometric-Series-Interpretation","page":"Theory","title":"Geometric Series Interpretation","text":"The inversion implements the geometric series:\n\nXi = I + chi + chi^2 + chi^3 + cdots\n\nEach term represents higher-order bubble contributions:\n\nI\n: Mean-field\nchi\n: Single bubble\nchi^2\n: Two bubbles\n...","category":"section"},{"location":"theory/#Time-Integration:-Adaptive-Kadanoff-Baym","page":"Theory","title":"Time Integration: Adaptive Kadanoff-Baym","text":"Achedmy uses the KadanoffBaym.jl package for adaptive time-stepping:\n\nInitial step: Coarse grid with user-specified dt\nError estimation: Local truncation error from ODE solver\nRefinement: Add points where error exceeds tolerance\nTwo-time propagation: Extend both t and t axes\n\nThis ensures accuracy while minimizing computational cost.","category":"section"},{"location":"theory/#Comparison-to-Other-Methods","page":"Theory","title":"Comparison to Other Methods","text":"","category":"section"},{"location":"theory/#vs.-Gillespie-SSA","page":"Theory","title":"vs. Gillespie SSA","text":"Aspect Gillespie Achedmy\nSpeed (two-time) ‚ö†Ô∏è Very slow ‚úì Fast\nAccuracy ‚úì Exact ‚âà Excellent\nMemory Low Moderate-High\nScalability Poor Good\n\nConclusion: Achedmy is 10-1000√ó faster for two-time correlations, with comparable accuracy.","category":"section"},{"location":"theory/#vs.-Linear-Noise-Approximation-(LNA)","page":"Theory","title":"vs. Linear Noise Approximation (LNA)","text":"Aspect LNA Achedmy\nRegime Near deterministic All regimes\nAccuracy Good (large N) Good (all N)\nMemory effects ‚úó ‚úì\nTwo-time Limited Full\n\nConclusion: Achedmy extends beyond LNA's Gaussian regime and includes memory effects.","category":"section"},{"location":"theory/#Further-Reading","page":"Theory","title":"Further Reading","text":"For detailed derivations and benchmarks, see:\n\nPlefka Expansion: Plefka (1982), Georges & Yedidia (1991)\nChemical Reaction Networks: Van Kampen (2007)\nKadanoff-Baym Equations: Kadanoff & Baym (1962), Balzer et al. (2013)","category":"section"},{"location":"theory/#See-Also","page":"Theory","title":"See Also","text":"Getting Started for practical usage\nExamples for applications to real systems\nAPI Reference for implementation details","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"Complete worked examples demonstrating Achedmy.jl for different biological systems.","category":"section"},{"location":"examples/#Example-1:-Enzyme-Kinetics-(Michaelis-Menten)","page":"Examples","title":"Example 1: Enzyme Kinetics (Michaelis-Menten)","text":"Classic enzyme-substrate dynamics with product formation.","category":"section"},{"location":"examples/#System-Definition","page":"Examples","title":"System Definition","text":"using Catalyst, Achedmy, Plots\n\n# Michaelis-Menten mechanism\nrn_enzyme = @reaction_network begin\n    kf, S + E --> SE    # Substrate + Enzyme ‚Üí Complex\n    kr, SE --> S + E    # Complex ‚Üí Substrate + Enzyme (unbinding)\n    kcat, SE --> P + E  # Complex ‚Üí Product + Enzyme (catalysis)\nend\n\n# Parameters (typical enzyme kinetics)\nkf = 0.01      # Binding rate\nkr = 1.0       # Unbinding rate  \nkcat = 0.5     # Catalytic rate\n\n# Initial conditions\nS0 = 100       # Substrate molecules\nE0 = 10        # Enzyme molecules\nSE0 = 0        # Complex (initially zero)\nP0 = 0         # Product (initially zero)","category":"section"},{"location":"examples/#Setup-and-Solve","page":"Examples","title":"Setup and Solve","text":"# Create system structure\nstructure = ReactionStructure(rn_enzyme, \n    [:S => S0, :E => E0, :SE => SE0, :P => P0])\n\n# Initialize variables with cross-species responses\n# (Important for S-E-SE coupling!)\nvariables = ReactionVariables(structure, \"cross\")\n\n# Solve with gSBR\nsol = solve_dynamics!(structure, variables,\n    selfEnergy = \"gSBR\",\n    tmax = 10.0,\n    abstol = 1e-6,\n    reltol = 1e-6\n)","category":"section"},{"location":"examples/#Analyze-Results","page":"Examples","title":"Analyze Results","text":"times = sol.t\n\n# Mean densities\nŒº_S = variables.Œº[1, :]   # Substrate\nŒº_E = variables.Œº[2, :]   # Enzyme  \nŒº_SE = variables.Œº[3, :]  # Complex\nŒº_P = variables.Œº[4, :]   # Product\n\n# Plot mean dynamics\nplot(times, Œº_S, label=\"‚ü®S‚ü©\", linewidth=2, xlabel=\"Time\", ylabel=\"Count\")\nplot!(times, Œº_E, label=\"‚ü®E‚ü©\", linewidth=2)\nplot!(times, Œº_SE, label=\"‚ü®SE‚ü©\", linewidth=2)\nplot!(times, Œº_P, label=\"‚ü®P‚ü©\", linewidth=2)\ntitle!(\"Enzyme Kinetics: Mean Dynamics\")\n\n# Equal-time variances\nvar_S = [variables.N[1,1,i,i] for i in 1:length(times)]\nvar_SE = [variables.N[3,3,i,i] for i in 1:length(times)]\n\nplot(times, var_S, label=\"Var(S)\", linewidth=2)\nplot!(times, var_SE, label=\"Var(SE)\", linewidth=2)\nxlabel!(\"Time\")\nylabel!(\"Variance\")\ntitle!(\"Fluctuations in Substrate and Complex\")\n\n# Cross-correlation between S and E\ncorr_SE = variables.N[1, 2, :, :]  # S-E correlation\nheatmap(times, times, corr_SE, \n    xlabel=\"t‚Ä≤\", ylabel=\"t\", \n    title=\"‚ü®ŒîS(t) ŒîE(t‚Ä≤)‚ü©\",\n    color=:viridis)","category":"section"},{"location":"examples/#Physical-Insights","page":"Examples","title":"Physical Insights","text":"Mean behavior: Substrate decreases, product increases, complex reaches steady-state\nFluctuations: Variance in SE larger than Poisson (œÉ¬≤ > Œº) due to binding bursts\nCorrelations: S-E anticorrelated (enzyme binding removes substrate)","category":"section"},{"location":"examples/#Comparison-of-Methods","page":"Examples","title":"Comparison of Methods","text":"# Compare different approximations\nmethods = [\"MAK\", \"MCA\", \"SBR\", \"gSBR\"]\nŒº_P_methods = []\n\nfor method in methods\n    vars = ReactionVariables(structure, \"single\")\n    solve_dynamics!(structure, vars, selfEnergy=method, tmax=10.0)\n    push!(Œº_P_methods, vars.Œº[4, :])\nend\n\n# Plot comparison\nplot(times, Œº_P_methods[1], label=\"MAK\", linewidth=2)\nplot!(times, Œº_P_methods[2], label=\"MCA\", linewidth=2)\nplot!(times, Œº_P_methods[3], label=\"SBR\", linewidth=2)  \nplot!(times, Œº_P_methods[4], label=\"gSBR\", linewidth=2, linestyle=:dash)\ntitle!(\"Product Formation: Method Comparison\")\n\n","category":"section"},{"location":"examples/#Example-2:-Gene-Regulation-(Toggle-Switch)","page":"Examples","title":"Example 2: Gene Regulation (Toggle Switch)","text":"Bistable genetic circuit with mutual repression.","category":"section"},{"location":"examples/#System-Definition-2","page":"Examples","title":"System Definition","text":"# Mutual repression network\nrn_gene = @reaction_network begin\n    k1 / (1 + (P2/K)^n), ‚àÖ --> P1    # P1 production (repressed by P2)\n    k2 / (1 + (P1/K)^n), ‚àÖ --> P2    # P2 production (repressed by P1)\n    Œ≥1, P1 --> ‚àÖ                      # P1 degradation\n    Œ≥2, P2 --> ‚àÖ                      # P2 degradation\nend\n\n# Parameters (bistable regime)\nk1 = 10.0     # Max production rate P1\nk2 = 10.0     # Max production rate P2  \nK = 50.0      # Repression threshold\nn = 2.0       # Hill coefficient\nŒ≥1 = 1.0      # Degradation rate P1\nŒ≥2 = 1.0      # Degradation rate P2","category":"section"},{"location":"examples/#Exploring-Bistability","page":"Examples","title":"Exploring Bistability","text":"# Try two different initial conditions\nIC_high_P1 = [:P1 => 80, :P2 => 10]\nIC_high_P2 = [:P1 => 10, :P2 => 80]\n\n# Simulate both\nstructure1 = ReactionStructure(rn_gene, IC_high_P1)\nvariables1 = ReactionVariables(structure1, \"single\")\nsol1 = solve_dynamics!(structure1, variables1, \n    selfEnergy=\"SBR\", tmax=20.0)\n\nstructure2 = ReactionStructure(rn_gene, IC_high_P2)\nvariables2 = ReactionVariables(structure2, \"single\")\nsol2 = solve_dynamics!(structure2, variables2,\n    selfEnergy=\"SBR\", tmax=20.0)\n\n# Plot phase portrait\nplot(variables1.Œº[1,:], variables1.Œº[2,:], \n    label=\"IC: High P1\", linewidth=2, \n    xlabel=\"‚ü®P1‚ü©\", ylabel=\"‚ü®P2‚ü©\")\nplot!(variables2.Œº[1,:], variables2.Œº[2,:], \n    label=\"IC: High P2\", linewidth=2)\nscatter!([IC_high_P1[1][2]], [IC_high_P1[2][2]], \n    label=\"Start 1\", markersize=8)\nscatter!([IC_high_P2[1][2]], [IC_high_P2[2][2]], \n    label=\"Start 2\", markersize=8)\ntitle!(\"Toggle Switch: Bistable Dynamics\")","category":"section"},{"location":"examples/#Switching-Dynamics","page":"Examples","title":"Switching Dynamics","text":"Study response to perturbations:\n\n# Start in State 1 (high P1)\nstructure = ReactionStructure(rn_gene, IC_high_P1)\nvariables = ReactionVariables(structure, \"cross\")\n\n# Solve to equilibrium\nsol = solve_dynamics!(structure, variables, \n    selfEnergy=\"gSBR\", tmax=30.0)\n\n# Response function shows how system reacts to perturbations\nR_P1_to_P2 = variables.R[1, 2, :, :]  # How P1(t) responds to Œ¥P2(t')\n\nheatmap(sol.t, sol.t, R_P1_to_P2,\n    xlabel=\"Perturbation time t‚Ä≤\",\n    ylabel=\"Response time t\",\n    title=\"R_{P1,P2}(t,t‚Ä≤): Cross-Response\")\n\n","category":"section"},{"location":"examples/#Example-3:-SIR-Infection-Dynamics","page":"Examples","title":"Example 3: SIR Infection Dynamics","text":"Susceptible-Infected-Recovered epidemic model.","category":"section"},{"location":"examples/#System-Definition-3","page":"Examples","title":"System Definition","text":"# SIR model with birth/death\nrn_sir = @reaction_network begin\n    Œ≤, S + I --> 2I      # Infection\n    Œ≥, I --> R           # Recovery\n    Œº, S --> ‚àÖ           # Natural death (S)\n    Œº, I --> ‚àÖ           # Natural death (I)\n    Œº, R --> ‚àÖ           # Natural death (R)\n    Œº*N_total, ‚àÖ --> S   # Birth (maintain population)\nend\n\n# Parameters (endemic regime)\nŒ≤ = 0.001     # Infection rate\nŒ≥ = 0.1       # Recovery rate\nŒº = 0.01      # Birth/death rate\nN_total = 1000  # Total population\n\n# Initial conditions (small outbreak)\nS0 = 990\nI0 = 10\nR0 = 0","category":"section"},{"location":"examples/#Epidemic-Outbreak","page":"Examples","title":"Epidemic Outbreak","text":"structure = ReactionStructure(rn_sir, [:S => S0, :I => I0, :R => R0])\nvariables = ReactionVariables(structure, \"single\")\n\n# Solve outbreak dynamics\nsol = solve_dynamics!(structure, variables,\n    selfEnergy = \"SBR\",\n    tmax = 200.0,\n    dt = 0.5\n)\n\ntimes = sol.t\nŒº_S = variables.Œº[1, :]\nŒº_I = variables.Œº[2, :]\nŒº_R = variables.Œº[3, :]\n\n# Plot SIR curves\nplot(times, Œº_S, label=\"Susceptible\", linewidth=2, \n    xlabel=\"Time (days)\", ylabel=\"Population\")\nplot!(times, Œº_I, label=\"Infected\", linewidth=2)\nplot!(times, Œº_R, label=\"Recovered\", linewidth=2)\ntitle!(\"SIR Epidemic Dynamics\")\n\n# Find peak infection time\npeak_idx = argmax(Œº_I)\npeak_time = times[peak_idx]\npeak_infected = Œº_I[peak_idx]\n\nprintln(\"Peak infection: $(peak_infected) at time $(peak_time)\")","category":"section"},{"location":"examples/#Variance-and-Stochastic-Effects","page":"Examples","title":"Variance and Stochastic Effects","text":"# Infection variance shows stochastic fluctuations\nvar_I = [variables.N[2,2,i,i] for i in 1:length(times)]\nstd_I = sqrt.(var_I)\n\nplot(times, Œº_I, ribbon=std_I, fillalpha=0.3,\n    label=\"‚ü®I‚ü© ¬± œÉ\", linewidth=2,\n    xlabel=\"Time (days)\", ylabel=\"Infected Count\")\ntitle!(\"Infection Dynamics with Uncertainty\")\n\n# Coefficient of variation\nCV_I = std_I ./ Œº_I\nplot(times, CV_I, label=\"CV(I)\", linewidth=2,\n    xlabel=\"Time (days)\", ylabel=\"Coefficient of Variation\")\ntitle!(\"Relative Fluctuations in Infected Population\")","category":"section"},{"location":"examples/#R-Estimation-from-Dynamics","page":"Examples","title":"R‚ÇÄ Estimation from Dynamics","text":"# Basic reproduction number from early growth\n# dI/dt ‚âà (Œ≤‚ü®S‚ü©/N - Œ≥)‚ü®I‚ü© at t‚Üí0\n\nearly_idx = 1:10  # First 10 time points\ngrowth_rates = diff(log.(Œº_I[early_idx])) ./ diff(times[early_idx])\navg_growth = mean(growth_rates)\n\nR0_estimated = 1 + avg_growth / Œ≥\nR0_theoretical = Œ≤ * S0 / (Œ≥ * N_total)\n\nprintln(\"R‚ÇÄ (theoretical): $(R0_theoretical)\")\nprintln(\"R‚ÇÄ (from dynamics): $(R0_estimated)\")\n\n","category":"section"},{"location":"examples/#Example-4:-Comparing-with-Gillespie-SSA","page":"Examples","title":"Example 4: Comparing with Gillespie SSA","text":"Validate Achedmy against exact stochastic simulations.\n\nusing JumpProcesses  # For Gillespie SSA\n\n# Simple birth-death process\nrn = @reaction_network begin\n    k_b, ‚àÖ --> X\n    k_d, X --> ‚àÖ\nend\n\nk_b = 10.0\nk_d = 1.0\nX0 = 0\n\n# Gillespie simulation (many trajectories)\nfunction gillespie_mean_variance(rn, X0, tmax, n_trajectories=1000)\n    # ... (Gillespie implementation)\n    # Returns: times, mean_X, var_X\nend\n\ntimes_gillespie, Œº_gillespie, var_gillespie = gillespie_mean_variance(rn, X0, 10.0)\n\n# Achedmy simulation\nstructure = ReactionStructure(rn, [:X => X0])\nvariables = ReactionVariables(structure, \"single\")\nsol = solve_dynamics!(structure, variables, \n    selfEnergy=\"MAK\", tmax=10.0)  # MAK exact for linear systems\n\n# Compare\nplot(times_gillespie, Œº_gillespie, label=\"Gillespie (1000 runs)\", \n    marker=:circle, linewidth=2)\nplot!(sol.t, variables.Œº[1,:], label=\"Achedmy (MAK)\", \n    linewidth=2, linestyle=:dash)\nxlabel!(\"Time\")\nylabel!(\"‚ü®X‚ü©\")\ntitle!(\"Birth-Death: Achedmy vs Gillespie\")\n\n# Variance comparison\nvar_achedmy = [variables.N[1,1,i,i] for i in 1:length(sol.t)]\nplot(times_gillespie, var_gillespie, label=\"Gillespie\", \n    marker=:circle, linewidth=2)\nplot!(sol.t, var_achedmy, label=\"Achedmy\", \n    linewidth=2, linestyle=:dash)\nxlabel!(\"Time\")\nylabel!(\"Var(X)\")\ntitle!(\"Variance: Perfect Agreement\")\n\n","category":"section"},{"location":"examples/#Performance-Benchmarking","page":"Examples","title":"Performance Benchmarking","text":"using BenchmarkTools\n\n# Benchmark different methods on enzyme kinetics\nstructure = ReactionStructure(rn_enzyme, [:S=>100, :E=>10, :SE=>0, :P=>0])\n\nfor method in [\"MAK\", \"MCA\", \"SBR\", \"gSBR\"]\n    variables = ReactionVariables(structure, \n        method in [\"gSBR\"] ? \"cross\" : \"single\")\n    \n    t_bench = @belapsed solve_dynamics!(\\$structure, \\$variables, \n        selfEnergy=\\$method, tmax=10.0)\n    \n    println(\"\\$(method): \\$(round(t_bench, digits=3))s\")\nend\n\n# Typical output:\n# MAK: 0.021s\n# MCA: 0.145s  \n# SBR: 0.183s\n# gSBR: 1.247s\n\n","category":"section"},{"location":"examples/#Tips-and-Tricks","page":"Examples","title":"Tips and Tricks","text":"","category":"section"},{"location":"examples/#Speeding-Up-Large-Systems","page":"Examples","title":"Speeding Up Large Systems","text":"# For large networks, use:\n# 1. Coarser time grid\nsol = solve_dynamics!(structure, variables, dt=0.5)  # Instead of 0.1\n\n# 2. Relaxed tolerances  \nsol = solve_dynamics!(structure, variables, abstol=1e-4, reltol=1e-4)\n\n# 3. Faster methods\nsol = solve_dynamics!(structure, variables, selfEnergy=\"SBR\")  # Instead of gSBR","category":"section"},{"location":"examples/#Saving-and-Loading-Results","page":"Examples","title":"Saving and Loading Results","text":"using JLD2\n\n# Save results\n@save \"enzyme_results.jld2\" structure variables sol\n\n# Load later\n@load \"enzyme_results.jld2\" structure variables sol\n\n# Continue simulation from saved state\nsol_extended = solve_dynamics!(structure, variables,\n    selfEnergy=\"gSBR\", tmax=20.0)  # Extends from previous tmax","category":"section"},{"location":"examples/#Extracting-Specific-Quantities","page":"Examples","title":"Extracting Specific Quantities","text":"# Autocorrelation function for species i\nfunction autocorr(variables, species_idx)\n    N_ii = variables.N[species_idx, species_idx, :, :]\n    Œº_i = variables.Œº[species_idx, :]\n    \n    # Normalized: C(t,t') = ‚ü®ŒîX(t)ŒîX(t')‚ü© / œÉ(t)œÉ(t')\n    œÉ_t = sqrt.(diag(N_ii))\n    C = N_ii ./ (œÉ_t * œÉ_t')\n    \n    return C\nend\n\n# Lag correlation: C(œÑ) where œÑ = t - t'\nfunction lag_correlation(variables, species_idx)\n    C = autocorr(variables, species_idx)\n    n = size(C, 1)\n    \n    # Extract œÑ=0, œÑ=1, œÑ=2, ... diagonals\n    lags = 0:(n-1)\n    C_lag = [mean(diag(C, k)) for k in lags]\n    \n    return lags, C_lag\nend\n\n# Usage\nlags, C_S = lag_correlation(variables, 1)  # Substrate autocorrelation\nplot(lags, C_S, marker=:circle, label=\"C_S(œÑ)\", \n    xlabel=\"Lag œÑ\", ylabel=\"Correlation\")","category":"section"},{"location":"examples/#Next-Steps","page":"Examples","title":"Next Steps","text":"Explore your own reaction networks\nTune parameters for your specific system\nCompare methods to find the best speed/accuracy trade-off\nCheck out the Theory page for mathematical details\nSee the API Reference for all available functions","category":"section"},{"location":"#Achedmy.jl-Documentation","page":"Home","title":"Achedmy.jl Documentation","text":"Achedmy.jl is a Julia package for simulating chemical reaction network dynamics using memory-corrected equations of motion derived from the Plefka expansion. The package provides fast, accurate approximations to the exact stochastic dynamics without requiring computationally expensive Gillespie simulations.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"Achedmy implements several approximation schemes for computing two-time response and correlation functions:\n\nMAK (Mean-field Approximation): Fastest, suitable for mean-field dominated systems\nMCA (Mode Coupling Approximation): O(Œ±¬≤) perturbative expansion\nSBR (Single-species Bubble Resummation): Self-consistent bubbles for each species\ngSBR (Generalized SBR): Full cross-species correlations (most accurate)","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"üöÄ Fast: 10-1000√ó faster than Gillespie for two-time quantities\nüìä Accurate: Captures memory effects and fluctuations beyond mean-field\nüîß Flexible: Works with any Catalyst.jl reaction network\nüìà Adaptive: Automatic time-grid refinement via KadanoffBaym.jl\nüßÆ Complete: Computes responses, correlations, and equal-time variances","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using Catalyst, Achedmy\n\n# Define enzyme kinetics network\nrn = @reaction_network begin\n    k1, S + E --> SE\n    k2, SE --> S + E  \n    k3, SE --> P + E\nend\n\n# Set up system\nstructure = ReactionStructure(rn, [:S=>100, :E=>10, :SE=>0, :P=>0])\nvariables = ReactionVariables(structure, \"single\")\n\n# Solve with gSBR approximation\nsol = solve_dynamics!(structure, variables, \n                     selfEnergy=\"gSBR\", \n                     tmax=5.0, \n                     abstol=1e-6)\n\n# Access results\nmeans = variables.Œº  # Mean densities\ncorrelations = variables.N  # Two-time correlations\nresponses = variables.R  # Two-time responses","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/btemoshir/Achedmy.jl\")","category":"section"},{"location":"#Documentation-Structure","page":"Home","title":"Documentation Structure","text":"Pages = [\n    \"tutorial.md\",\n    \"theory.md\",\n    \"examples.md\",\n    \"api.md\"\n]\nDepth = 2","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use Achedmy.jl in your research, please cite:\n\n@article{achedmy2024,\n  title={Memory-corrected dynamics of chemical reaction networks},\n  author={Your Name},\n  journal={Journal Name},\n  year={2024}\n}","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"tutorial/#Getting-Started-Tutorial","page":"Getting Started","title":"Getting Started Tutorial","text":"This tutorial will walk you through using Achedmy.jl to simulate chemical reaction networks, from defining the system to analyzing results.","category":"section"},{"location":"tutorial/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"Make sure you have installed:\n\nusing Pkg\nPkg.add(\"Catalyst\")\nPkg.add(\"KadanoffBaym\")\nPkg.add(\"Plots\")  # For visualization","category":"section"},{"location":"tutorial/#Step-1:-Define-Your-Reaction-Network","page":"Getting Started","title":"Step 1: Define Your Reaction Network","text":"Achedmy uses Catalyst.jl's Domain-Specific Language (DSL) to define reactions:\n\nusing Catalyst\n\n# Simple gene expression: ‚àÖ ‚áÑ mRNA ‚Üí Protein\nrn = @reaction_network begin\n    k_on,  ‚àÖ --> M    # Transcription\n    k_off, M --> ‚àÖ    # mRNA degradation\n    k_p,   M --> M + P  # Translation\n    Œ≥_p,   P --> ‚àÖ    # Protein degradation\nend\n\n# Set parameter values\nk_on = 1.0\nk_off = 0.1\nk_p = 10.0\nŒ≥_p = 1.0","category":"section"},{"location":"tutorial/#Supported-Reaction-Types","page":"Getting Started","title":"Supported Reaction Types","text":"Zeroth-order: ‚àÖ ‚Üí A (production)\nFirst-order: A ‚Üí B, A ‚Üí ‚àÖ (conversion, degradation)\nSecond-order: A + B ‚Üí C, 2A ‚Üí B (binding, dimerization)\nReversible: Any combination with ‚áÑ","category":"section"},{"location":"tutorial/#Step-2:-Create-the-System-Structure","page":"Getting Started","title":"Step 2: Create the System Structure","text":"The ReactionStructure parses your network and sets initial conditions:\n\nusing Achedmy\n\n# Define initial species counts\ninitial_conditions = [:M => 0, :P => 0]\n\n# Create structure (handles stoichiometry, rates, etc.)\nstructure = ReactionStructure(rn, initial_conditions)\n\n# Inspect the structure\nprintln(\"Number of species: \", structure.num_species)\nprintln(\"Number of reactions: \", structure.num_interactions)\nprintln(\"Initial densities: \", structure.Œº0)","category":"section"},{"location":"tutorial/#What's-Inside-ReactionStructure?","page":"Getting Started","title":"What's Inside ReactionStructure?","text":"stochiometry_prod: Product stoichiometry matrix (S)\nstochiometry_react: Reactant stoichiometry matrix (R)  \nrate_interaction: Reaction rates (k)\nnum_species: Number of species (N)\nnum_interactions: Number of reactions\nŒº0: Initial mean densities","category":"section"},{"location":"tutorial/#Step-3:-Initialize-Variables","page":"Getting Started","title":"Step 3: Initialize Variables","text":"ReactionVariables stores the dynamical quantities (responses, correlations):\n\n# Choose response function type:\n# \"single\" = diagonal only (fast, memory efficient)\n# \"cross\"  = full cross-species (slower, more accurate)\n\nvariables = ReactionVariables(structure, \"single\")","category":"section"},{"location":"tutorial/#Variable-Storage","page":"Getting Started","title":"Variable Storage","text":"The variables object contains:\n\nŒº: Mean densities Œº·µ¢(t)\nR: Response functions R·µ¢‚±º(t,t‚Ä≤)\nN: Correlation functions N·µ¢‚±º(t,t‚Ä≤)\nŒ£_R, Œ£_Œº, Œ£_B: Self-energies (memory kernels)","category":"section"},{"location":"tutorial/#Step-4:-Solve-the-Dynamics","page":"Getting Started","title":"Step 4: Solve the Dynamics","text":"Now run the simulation with your chosen approximation method:\n\n# Solve with gSBR (generalized SBR - most accurate)\nsol = solve_dynamics!(\n    structure, \n    variables,\n    selfEnergy = \"gSBR\",   # Approximation: \"MAK\", \"MCA\", \"SBR\", \"gSBR\"\n    tmax = 10.0,            # Maximum simulation time\n    abstol = 1e-6,          # Absolute tolerance\n    reltol = 1e-6,          # Relative tolerance\n    dt = 0.1                # Initial time step\n)","category":"section"},{"location":"tutorial/#Choosing-an-Approximation-Method","page":"Getting Started","title":"Choosing an Approximation Method","text":"Method Speed Accuracy When to Use\nMAK ‚ö°‚ö°‚ö°‚ö° ‚≠ê Quick estimates, mean-field systems\nMCA ‚ö°‚ö°‚ö° ‚≠ê‚≠ê Weak fluctuations, perturbative regime\nSBR ‚ö°‚ö° ‚≠ê‚≠ê‚≠ê Single-species dominant, moderate coupling\ngSBR ‚ö° ‚≠ê‚≠ê‚≠ê‚≠ê Strong coupling, cross-species correlations","category":"section"},{"location":"tutorial/#Step-5:-Access-Results","page":"Getting Started","title":"Step 5: Access Results","text":"After solving, extract the results from variables:\n\n# Time grid (adaptive, from KadanoffBaym.jl)\ntimes = sol.t\n\n# Mean densities over time\nŒº_M = variables.Œº[1, :]  # mRNA\nŒº_P = variables.Œº[2, :]  # Protein\n\n# Equal-time variances\nvar_M = variables.N[1, 1, :, :]  # Diagonal: œÉ¬≤_M(t)\nvar_P = variables.N[2, 2, :, :]\n\n# Cross-correlation (if using \"cross\" response type)\ncorr_MP = variables.N[1, 2, :, :]  # ‚ü®ŒîM(t) ŒîP(t‚Ä≤)‚ü©","category":"section"},{"location":"tutorial/#Two-Time-Structure","page":"Getting Started","title":"Two-Time Structure","text":"The correlation functions N[i,j,t,t‚Ä≤] and responses R[i,j,t,t‚Ä≤] have two time indices:\n\nt: Later time (rows)\nt‚Ä≤: Earlier time (columns)\nDiagonal N[i,i,t,t]: Equal-time variance œÉ·µ¢¬≤(t)\nOff-time N[i,i,t,t‚Ä≤]: Autocorrelation (t ‚â† t‚Ä≤)","category":"section"},{"location":"tutorial/#Step-6:-Visualization","page":"Getting Started","title":"Step 6: Visualization","text":"Plot your results using Plots.jl:\n\nusing Plots\n\n# Plot mean densities\nplot(times, Œº_M, label=\"‚ü®M‚ü©\", xlabel=\"Time\", ylabel=\"Density\")\nplot!(times, Œº_P, label=\"‚ü®P‚ü©\")\n\n# Plot variances\nplot(times, [var_M[i,i] for i in 1:length(times)], \n     label=\"Var(M)\", xlabel=\"Time\", ylabel=\"Variance\")\nplot!(times, [var_P[i,i] for i in 1:length(times)], \n      label=\"Var(P)\")\n\n# Heatmap of correlation function\nheatmap(times, times, corr_MP, \n        xlabel=\"t‚Ä≤\", ylabel=\"t\", title=\"‚ü®ŒîM(t) ŒîP(t‚Ä≤)‚ü©\")","category":"section"},{"location":"tutorial/#Common-Issues-and-Solutions","page":"Getting Started","title":"Common Issues and Solutions","text":"","category":"section"},{"location":"tutorial/#Issue:-Simulation-is-too-slow","page":"Getting Started","title":"Issue: Simulation is too slow","text":"Solutions:\n\nUse faster approximation (\"SBR\" or \"MAK\" instead of \"gSBR\")\nIncrease tolerances (abstol=1e-4, reltol=1e-4)\nUse \"single\" response type instead of \"cross\"\nReduce tmax or increase dt","category":"section"},{"location":"tutorial/#Issue:-Results-are-inaccurate","page":"Getting Started","title":"Issue: Results are inaccurate","text":"Solutions:\n\nUse more accurate approximation (\"gSBR\" instead of \"MCA\")\nDecrease tolerances (abstol=1e-8, reltol=1e-8)\nUse \"cross\" response type for strongly coupled species\nCheck if initial conditions are in valid regime","category":"section"},{"location":"tutorial/#Issue:-Memory-errors","page":"Getting Started","title":"Issue: Memory errors","text":"Solutions:\n\nUse \"single\" instead of \"cross\" response type\nReduce tmax (fewer time points)\nIncrease dt (coarser grid)\nUse MAK or MCA (smaller memory footprint)","category":"section"},{"location":"tutorial/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Read the Theory page to understand the mathematical framework\nExplore Examples for complete worked examples\nCheck the API Reference for detailed function documentation","category":"section"},{"location":"tutorial/#Complete-Example","page":"Getting Started","title":"Complete Example","text":"Putting it all together:\n\nusing Catalyst, Achedmy, Plots\n\n# Define system\nrn = @reaction_network begin\n    1.0, ‚àÖ --> M\n    0.1, M --> ‚àÖ\n    10.0, M --> M + P\n    1.0, P --> ‚àÖ\nend\n\n# Set up and solve\nstructure = ReactionStructure(rn, [:M => 0, :P => 0])\nvariables = ReactionVariables(structure, \"single\")\nsol = solve_dynamics!(structure, variables, \n                     selfEnergy=\"gSBR\", tmax=10.0)\n\n# Plot results\ntimes = sol.t\nplot(times, variables.Œº[1,:], label=\"‚ü®M‚ü©\")\nplot!(times, variables.Œº[2,:], label=\"‚ü®P‚ü©\")\n\nThat's it! You've successfully simulated a chemical reaction network with Achedmy.jl. üéâ","category":"section"}]
}
